	
	第一天
		
nosql===>redis+mysql
键 值
string---》字符串，int
hash---->字典
list----》列表
set-----》集合
zset----》有序集合
====================版本控制系统
作用：更方便的管理源代码
对于个人：后悔药
对于团队：合并
====================git简介
分布式：将数据存储在多台电脑上
版本控制：
====================单人本地操作
git init--->将磁盘目录变成仓库，会在目录下新建隐藏目录.git
git status--->查看工作区，是否有内容需要提交
git add .===>将当前目录的内容由工作区加入到暂存区
git commit -m '说明信息'---->将暂存区的内容提交到仓库区
git log或git reflog====>查看历史版本信息
git reset 版本号====》将仓库区的指定版本恢复到暂存区
git checkout -- 文件名====>将暂存区指定的文件恢复到工作区
====================多人远程操作
命令：与服务器交互的命令
------创建远程仓库
1.https://gitee.com/，注册账号
2.新建仓库
3.创建忽略文件.gitignore
	*.pyc
	.idea/
------配置SSH
1.sudo rm -rf .ssh
2.ssh-keygen -t rsa -C "注册gitee时的邮箱"
3.三次回车
4.cd .ssh
5.cat id_rsa.pub
6.复制公钥，到gitee中进行添加
------克隆项目
git clone 地址
------多人协同开发
git push origin master===>某个员工将本地文件，提交到服务器
git pull====>从服务器获取代码
------代码冲突
当多个员工，修改同一个文件时，会产生冲突
协商
------标签
阶段性的标记
------分支
每个员工在不同的分支上写代码，互不影响
公用分支：
	dev--->开发的阶段性合并
	master-->在dev分支的代码，经测试无bug后，由经理合并过来，再由运维进行布署
git branch===>查看所有分支
git branch 名称===》新建分支
git checkout 名称===》切换分支
git merge 分支名称===》将指定分支的代码，合并到当前分支
====================总结
1.注册gitee.com账号
2.新建仓库
3.新建.gitignore文件
	*.pyc
	.idea/
4.新建分支dev
5.配置ssh公钥
6.克隆git clone ****
7.根据服务器创建dev分支
	git checkout -b dev origin/dev
8.新建自己的分支
	git checkout -b itcast
9.在仓库目录下，新建项目，如xjzx
10.复制资源到项目中
11.使用最多的命令：
	git add .
	git commit -m ''
	git push origin itcast
https://www.yuntongxun.com/===>免费发送短信
https://www.qiniu.com/========>免费的文件存储服务器


	第二天
	
git的作用---景雷
	Git是一款分布式版本控制系统
	分布式：可以将代码存储在多台电脑上，互为备份
	版本控制系统：对于单人或多人，更方便的管理源代码
创建仓库并添加忽略文件---张凌钘
	以gitee为例
	创建.gitignore文件
	*.pyc
	.idea/
常用命令---李振华
	git add .
	git commit -m ''
	git push origin 分支
分支命令---刘冬冬
	git branch
	git checkout 
	git merge 分支名称
====================反馈
*** 公钥是每个项目都得创建一个上传到服务器吗？换个路径之类的需要重新生成么？ 
答：每个项目都得添加钥匙
	在linux中只生成一次即可
*** 课堂反馈时间不合适，太早了，建议在放在晚上九点以后。 
王军航 项目一脸懵. 
马健茹 老师讲的很详细，知识点反复总结 
王功镖 吸收比较慢 
====================项目框架搭建
xjzx11--->仓库
xjzx--->项目
info--->项目的代码
	config.py--->配置（复制粘贴，改等号右边的值）
		1.mysql的连接
		2.redis的连接
		3.session的配置
	init.py--->封装创建flask对象的方法
		创建app对象时：
			1.加载配置
			2.初始化mysql
			3.初始化redis
			4.启动CSRF保护
			5.启动Session存储到redis中
			6.启动日志(复制粘贴)
	modules---->存放所有的视图
		index--->存放首页的视图
			__init__.py--->创建蓝图对象
			views.py--->定义视图函数
			修改info/__init__.py文件的create_app函数，添加注册蓝图的代码
xjzx.py--->manage.py--->启动项目
====================在pycharm中管理仓库
ctrl+alt+a===>git add .
ctrl+k=======>git commit -m ''
ctrl+shift+k==>git push origin itcast
====================模型类
数据表：
	用户
	新闻
	新闻分类
	评论（回复）
	点赞
关系表：
	用户发布新闻为1对多，则在多的端定义外键，在1的端定义关系属性
	用户收藏新闻为多对多，则新建外键表，在任意端定义关系属性
	分类与新闻为1对多，则在新闻中定义外键，在分类中定义关系属性
	新闻与评论为1对多，则。。。。。
	评论与回复为1对多，则。。。，自关联
	评论与点赞为1对多，。。。。。
	用户关注作者为多对多，则新建外键表，在任意端定义关系属性
		特别说明：用户与作者是同一张表，属于自关联
====================关系
一对多的关系，如分类与新闻
	定义：
		外键：在News类中category_id = db.Column(db.Integer, db.ForeignKey("info_category.id"))
		关系属性：在Category类中news_list = db.relationship('News', backref='category', lazy='dynamic')
	使用：已知分类对象category，获取对应的新闻category.news_list====>select * from news where category_id=category.id
		已知新闻对象news，获取对应的分类对象news.category====>select * from category where id=news.category_id
一对多的自关联，如评论与回复
	定义
	    外键：在回复表中，parent_id = db.Column(db.Integer, db.ForeignKey("info_comment.id"))  # 父评论id
		关系属性：在评论表中，表示根据评论找回复backs_list=db.relationship('Comment',lazy='dynamic',backref='comemnt')
	使用：
		已知评论对象comment，获取回复comment.backs_list=======>select * from comment where parent_id=comment.id
		已知回复对象back，获取评论对象back.comment============>select * from comment where id=back.parent_id
多对多的关系，如用户收藏新闻
	定义：
		外键：新表
			tb_user_news_collection = db.Table(
				"info_user_news_collection",
				db.Column("user_id", db.Integer, db.ForeignKey("info_user.id"), primary_key=True),  # 新闻编号
				db.Column("news_id", db.Integer, db.ForeignKey("info_news.id"), primary_key=True),  # 分类编号
				db.Column("create_time", db.DateTime, default=datetime.now)  # 收藏创建时间
			)
		关系属性：随便，此处写在了用户表中
			collection_news = db.relationship(
				"News", 
				secondary=tb_user_news_collection, 
				lazy="dynamic",
				#backref='user_list'
				backref=db.backref('user_list',lazy='dynamic')
			)
	使用：
		已知用户对象user，获取所有收藏的新闻user.collection_news=======>select news_id from info_user_news_collection where user_id=user.id
			select * from news where id in (select news_id from info_user_news_collection where user_id=user.id)
		已知新闻对象news，获取所有收藏这个新闻的用户news.user_list=====>select user_id from info_user_news_collection where news_id=news.id
			select * from user where id in (select user_id from info_user_news_collection where news_id=news.id)
多对多的自关联，如用户关注作者
	定义：
		外键：中间表
			tb_user_author = db.Table(
				"info_user_author",
				db.Column('user_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True),  # 浏览者编号
				db.Column('author_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True)  # 作者编号
			)
		关系属性：因为作者、用户是同一个类，所以就定义在这个类中
			authors = db.relationship(
				'User',
				lazy='dynamic',
				secondary=tb_user_author,
				primaryjoin=id == tb_user_author.c.user_id,
				secondaryjoin=id == tb_user_author.c.author_id,
				backref=db.backref('users', lazy='dynamic')
			)
	使用：
		已知用户对象user，获取关注的作者user.authors====>select author_id from tb_user_author where ***=user.id===>user_id=user.id
			select * from users where id in (select author_id from tb_user_author where user_id=user.id)
		已知用户对象author，获取关注这个作者的用户author.users====>select user_id from tb_user_author where ***=user.id===>author_id=user.id
			select * from user where id in (select user_id from tb_user_author where ***=user.id)s
====================总结
能够使用 Pycharm 对项目进行一系列源代码管理操作
	1.在settings中添加
	2.ctrl+alt+a
	3.ctrl+k
	4.ctrl+shift+k
能够根据需求写出项目中所使用的SQLAlchemy、Session、Redis相关配置
	1.复制代码
	2.修改配置
能够参照课件思路抽取出项目入口文件 manage.py
	1.新xjzx.py===>manage.py
	2.创建app对象
	3.创建manager对象
	4.在main中启动项目manage.run()
能够说出日志记录在项目中的作用
	记录代码运行过程中的错误信息，方便开发人员维护代码，修改bug
能够集成Flask-Script扩展使项目支持命令行的形式运行
	扩展迁移命令
	Migrate(app,db)
	manager.add_command('db',MigrateCommand)
	
	第三天
	
项目目录结构：王功镖
	xjzx.py===>manage.py==>启动项目
	info==>开发人员编写的代码
		__init__.py===>create_app()
		config.py===>配置
		models.py==>定义模型类
		modules-->定义蓝图，创建视图
配置：杨光
	xjzx/info/config.py
	mysql连接
	redis连接
	session的保存方案
创建Flask对象：范一帆
	xjzx/info/__init__.py
	创建Flask对象
	加载配置
	初始化mysql连接
	初始化redis连接
	启用CSRF保护
	启用Session保存到redis
	启用日志
关系的定义与使用：
	一对多：
		定义：
			外键：多
			关系属性：一
		调用：对象.属性
	一对多自关联：当前一与多是同一个模型类，所以外键、关系属性定义在同一个类中
		remote_side=[]===>自关联，当关系属性定义在多端时，使用，指向主键
	多对多
		定义：
			外键：中间表
			关系属性：任意端
		调用：对象.属性
	多对多自关联：primaryjoin指定主的关系
		sencondaryjoin：指定backref的关系
====================反馈
*** 项目还没吸收完，这么早做课堂反馈让我咋做。。。 
*** 同学们都是并口硬盘，老师是M.2固态，请给一点反应时间，我们读写速度有点慢 
*** 1.redis list中有想同的元素，怎么在第二个元素前后插入值 
答：没有
	将所有数据读取到python中，在python中操作完成后，再写入到redis
2.session 默认不是放在服务器吗？记得之前听说的是cookie存在本地，session存在服务器，但是两者都是在服务器设置 
答：session在flask中默认保存在cookie中
	经过flask_session的配置，可以保存到redis
*** 远程项目和公钥创建有现后顺序吗? 多人开发如何push上去,是所有开发者的电脑需要配置公钥和经理的一致吗? 
答：顺序没有关系
	每个员工都生成一个私钥、公钥，然后将自己的公钥发给经理，经理将公钥配置到项目中
*** app.config是怎么 .get() 到内容的 
答：flask中定义好的
	Flask()
*** 一个程序的相关配置信息还是希望仔细讲一下，我自己提前3天开始配置，配置了好几遍，看着代码我会配置，脱离代码一脸懵逼，完完全全的没一丁点思路，
	其结果就是当接手项目时间只会复制粘贴。这些配置对于经验丰富的程序员大牛来说，只是浪费时间，但对于刚开始第一个小项目的我来说，希望尽可能的多了解。
	当然班级里也有很多基础好的，不用敲这些配置，希望老师能根据大部分学生的接受程度进行相关课程的安排，如果都吸收比较好，那么我就在下面继续练习吧。 
答：在实际开发中，关于配置的代码都是复制粘贴，然后修改等号右侧的内容
王朝 remote_side=[id] 可以替代 backref='childs' 吗自关联一对多有没有指向不能明确的问题 redis的数据库是16个数据库是什么概念 是可以并行的吗 
答：remote_side在一对多自关联中使用，不能取代backref
	redis中默认存在16个数据库，编号是0-15
	select 编号
====================图形验证码
1.引入第三方包，用于绘制图形验证码
2.调用包中的函数，生成验证码文本、图片数据
3.接收客户端的唯一标识，将验证码文本保存到redis中
4.将图片数据构造响应对象，返回给浏览器
====================短信验证码
1.接收
	手机号
	图形验证码
	图形唯一标识
2.验证
	图形验证码是否正确
	手机号格式
	手机号是否存在
3.处理
	生成6位随机数
	发短信
	保存到redis
4.响应
====================对接云通讯
1.注册登录
2.阅读官方文档
3.拷贝示例代码
4.修改自己的账号信息
5.调用
====================注册
1.接收：手机号、短信验证码、密码
2.验证：非空，短信验证码
3.处理：新建User对象，属性赋值，保存
4.响应：返回json
====================登录
业务逻辑：根据手机号与密码，到用户表中查询数据，如果查到则成功，否则失败
1.接收：手机号，密码
2.验证：正则表达式验证
3.处理：查询
4.响应：json
====================退出
删除session中的键
====================CSRF
1.定义请求勾子函数
2.生成口令值
3.输出到cookie中
4.发起post请求的js读取cookie
5.包含到请求报文的头中
====================总结
能够说出当前项目注册的图片验证码验证逻辑
	1.生成图片验证码，保存在redis中
	2.提交时，接收用户输入的图片验证码
	3.从redis中读取图片验证码
	4.对比两个图片验证码
能够写出后端提供图片验证码的视图函数逻辑
	1.拷贝第三方的包
	2.引入函数，生成图形验证码
	3.将文本保存到redis中
	4.将图片的二进制数据输出到浏览器
	注意：设置响应报文的头为Content-Type：image/jpg
能够参考课件步骤写出发送短信验码的后端代码逻辑
	1.接收手机号、图形验证码
	2.验证
	3.生成随机的6位验证码
	4.导入第三方包，调用方法，发送短信（阅读官方文档）
	5.将验证码保存到redis中
能够参考课件步骤写出注册功能的后端代码逻辑
	1.接收手机号、短信验证码、密码
	2.验证
	3.创建用户对象，为属性赋值，保存
能够使用代码实现登录的后端逻辑
	1.接收手机号、密码
	2.查询验证
	3.响应
	说明：登录成功后，进行状态保持
能够使用代码实现退出登录后端逻辑
	1.删除session中的键
	2.响应
